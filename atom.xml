<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Coding Life</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://codinglife.tech/"/>
  <updated>2019-09-17T08:51:44.781Z</updated>
  <id>https://codinglife.tech/</id>
  
  <author>
    <name>Max Peng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM 执行 Java 程序时的内存区域划分</title>
    <link href="https://codinglife.tech/2019/09/java-virtual-machine-runtime-memory-layout/"/>
    <id>https://codinglife.tech/2019/09/java-virtual-machine-runtime-memory-layout/</id>
    <published>2019-09-17T02:28:03.000Z</published>
    <updated>2019-09-17T08:51:44.781Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/jvm-memory-layout.png" alt="JVM Memory Layout"></p><p>在学习 Java 虚拟机（后面简称：<code>JVM</code>）中的垃圾回收机制（GC）之前，先需要了解 在 JVM 中的 Java 程序（class 文件）加载到内存之后到底是怎么存的。在阅读了 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5" target="_blank" rel="noopener"><strong>JVM规范</strong></a>和周志明的<a href="https://book.douban.com/subject/24722612/" target="_blank" rel="noopener"><strong>《深入理解Java虚拟机（第2版）》</strong></a>之后，总结一下JVM中的内存划分以及各个区域的作用。</p><a id="more"></a><p>在JVM规范中定义了5种运行时的数据区域：程序计数器（Program Counter Register）、Java虚拟机栈（JVM Stacks）、堆（Heap）、方法区（Method Area）、运行时常量池（Runtime Constant Pool）、本地方法栈（Native Method Stack）。在周志明的书中还提到了直接内存（Direct Memory），它并不是JVM运行时数据区域的一部分，在JVM的规范中也没有相关的定义。下面分别来说明各自的用途。</p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器，也叫PC Register。它的用途很单一，但是却是很多功能的基础。如果线程当前执行的是Native方法，那么寄存器里的值就是Undefined；如果线程当前执行的是非Native方法，那么寄存器里的值就是当前执行的JVM字节码指令的地址。像我们常用的分支、循环、跳转、异常处理、线程恢复等都依赖于它。</p><p>由于JVM支持多个线程同时执行，所以每个线程都有一个独立的程序计数器，各个线程互不影响，这类内存区域也称之为<strong>线程私有</strong>的。</p><h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><p>虚拟机栈也是<strong>线程私有</strong>的，随着一个线程的创建而创建，主要用来存储栈帧（Stack Frame）。什么是栈帧呢？在Java中，每个方法在执行时就会先创建一个栈帧并放入虚拟机栈中，在方法执行完毕时再从虚拟机栈中移除该栈帧。它主要用来存储局部变量表、操作数栈、动态链接、方法出口等信息。我们常说的堆（Heap）和栈（Stack）中的栈，指的就是虚拟机栈。</p><p>在JVM规范中并没有对虚拟机栈空间的大小做限制，可以设置为固定大小的，也可以设置为可扩展的。但是在规范中定义了两种异常情况：</p><ul><li>如果计算时请求的栈空间大于虚拟机栈的最大值，则会抛出<code>StackOverflowError</code>异常；</li><li>如果虚拟机栈设置为可扩展的并且无法再获取更多内存时，则会抛出<code>OutOfMemoryError</code>异常。</li></ul><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>相比而言，堆在JVM管理的内存区域中属于最大的一块，随着虚拟机的启动而创建，用来存储所有的class实例和数组，所有<strong>线程共享</strong>这一区域，该区域也是垃圾回收的主要区域。虽然JVM规范中说所有的对象实例都在该区域分配空间，但是随着JIT技术的逐步发展，这一说法也不严谨了。</p><p>堆空间的大小也可以设置为固定大小，或者可扩展的。但不管是何种方式，规范中还是定义了一种异常场景：</p><ul><li>如果计算需要更多的堆空间而无法满足时，则会抛出<code>OutOfMemoryError</code>异常。</li></ul><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区和堆一样，也是随着虚拟机启动而创建，所有<strong>线程共享</strong>，主要用来存储被JVM加载的类信息、常量、静态变量等信息。</p><p>JVM规范中并未严格要求要对该区域进行垃圾回收，但是HotSpot虚拟机在垃圾回收的时候还是会考虑该区域，在分代垃圾回收中所说的“<strong>永久代</strong>”指的就是方法区。方法区的大小也可以设置为固定大小，或者可扩展的。但不管是何种方式，规范中还是定义了一种异常场景：</p><ul><li>如果计算需要更多的方法区空间而无法满足时，则会抛出<code>OutOfMemoryError</code>异常。</li></ul><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>运行时常量池是方法区的一部分，用于存储编译期生成的各种字面量和符号引用。在Java中并不要求常量一定只有编译期才能产生，运行期间也可能将新的常量放入池中，例如<code>String</code>类的<code>intern()</code>方法。</p><p>每个运行时常量池都是随着一个类或者接口的创建而创建的。在规范中定义了一种异常场景：</p><ul><li>在创建一个类或者接口时，如果运行时的常量池无法分配到足够的空间时，则会抛出<code>OutOfMemoryError</code>异常。</li></ul><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈和虚拟机栈类似，也是<strong>线程私有</strong>的，随着一个线程的创建而创建，只不过虚拟机栈是用来服务Java方法调用，而本地方法栈是用来服务本地方法调用的。</p><p>在JVM规范中并没有对本地方法栈空间的大小做限制，可以设置为固定大小的，也可以设置为可扩展的。在规范中也定义了两种异常情况：</p><ul><li>如果计算时请求的栈空间大于本地方法栈的最大值，则会抛出<code>StackOverflowError</code>异常；</li><li>如果本地方法栈设置为可扩展的并且无法再获取更多内存时，则会抛出<code>OutOfMemoryError</code>异常。</li></ul><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存*"></a>直接内存<sup>*</sup></h2><p>直接内存不受虚拟机参数的控制，在NIO中有一种基于通道（Channel）与缓冲区（Buffer)的I/O方式，它可以通过Native方法在堆外分配内存，然后通过DirectByteBuffer对象来引用这块内存。因为避免了在Java堆和Native堆之间来回复制数据，从而在某些场景中能够得到性能的提升。一旦使用的直接内存超过了物理内存的总和，则会抛出<code>OutOfMemoryError</code>异常。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/jvm-memory-layout.png&quot; alt=&quot;JVM Memory Layout&quot;&gt;&lt;/p&gt;
&lt;p&gt;在学习 Java 虚拟机（后面简称：&lt;code&gt;JVM&lt;/code&gt;）中的垃圾回收机制（GC）之前，先需要了解 在 JVM 中的 Java 程序（class 文件）加载到内存之后到底是怎么存的。在阅读了 &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;JVM规范&lt;/strong&gt;&lt;/a&gt;和周志明的&lt;a href=&quot;https://book.douban.com/subject/24722612/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;《深入理解Java虚拟机（第2版）》&lt;/strong&gt;&lt;/a&gt;之后，总结一下JVM中的内存划分以及各个区域的作用。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://codinglife.tech/categories/Java/"/>
    
    
      <category term="JVM" scheme="https://codinglife.tech/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>在MySQL中使用LAST_INSERT_ID获取唯一自增序列</title>
    <link href="https://codinglife.tech/2019/07/implement-sequence-with-mysql-last-insert-id/"/>
    <id>https://codinglife.tech/2019/07/implement-sequence-with-mysql-last-insert-id/</id>
    <published>2019-07-15T12:03:02.000Z</published>
    <updated>2019-07-16T07:07:21.312Z</updated>
    
    <content type="html"><![CDATA[<p>一般如果遇到生成全局唯一的自增ID的需求时，往往第一反应都是直接利用数据的Sequence对象，简单，直接了当。但是MySQL偏偏不支持Sequence对象，那我们该如何是好呢？</p><h2 id="什么是Sequence"><a href="#什么是Sequence" class="headerlink" title="什么是Sequence"></a>什么是Sequence</h2><p>Sequence也叫做序列，一般用做表的主键，或者一些项目的编号等。一般具有以下几个特点：</p><ul><li>全表唯一</li><li>自增</li><li>不一定严格连续（中间由于事务的回滚可能会出现<code>洞</code>，比如1，2，3，5，6）</li></ul><a id="more"></a><p>在常见的几种数据库中，Oracle、SQL Server都内置有Sequence对象，具体用法就不在此赘述了。在本文中我们来讨论一下如何在原生不支持Sequence的MySQL（目前最新的大版本为8.0）中模拟出Sequence的效果。</p><h2 id="如何在MySQL中模拟Sequence"><a href="#如何在MySQL中模拟Sequence" class="headerlink" title="如何在MySQL中模拟Sequence"></a>如何在MySQL中模拟Sequence</h2><p>MySQL中的<code>auto_increment</code>一般是用来生成表的主键，本身能够生成自增的唯一ID，但是一张表只能有一个列带有<code>auto_increment</code>属性。在实际项目中，我们可能需要不止一种序列号，比如项目编号（PROJ-001，PROJ-002…）、发票编号（INV-0001，INV-0002…），订单编号（ORD-0001，ORD-0002…）等等，下面将通过<code>auto_increment</code>和<code>LAST_INSERT_ID</code>相结合实现该功能。</p><h3 id="LAST-INSERT-ID函数"><a href="#LAST-INSERT-ID函数" class="headerlink" title="LAST_INSERT_ID函数"></a>LAST_INSERT_ID函数</h3><p>该函数有两种形式：<a href="https://dev.mysql.com/doc/refman/8.0/en/information-functions.html#function_last-insert-id" target="_blank" rel="noopener"><code>LAST_INSERT_ID()</code></a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/information-functions.html#function_last-insert-id" target="_blank" rel="noopener"><code>LAST_INSERT_ID(expr)</code></a>。无参的形式会返回最近一次执行<code>INSERT</code>语句时<code>auto_increment</code>的值；带<code>expr</code>的形式会返回表达式的值，并且该值会被记住，在下一次调用<code>LAST_INSERT_ID()</code>时也返回该值。下面我们来看一个例子。</p><p>首先创建一张表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE user (</span><br><span class="line">    id INT AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">    name VARCHAR(50) NOT NULL</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>然后插入两条数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO user(name) VALUES(&apos;张三&apos;);</span><br><span class="line">INSERT INTO user(name) VALUES(&apos;李四&apos;);</span><br><span class="line"></span><br><span class="line">SELECT LAST_INSERT_ID();</span><br></pre></td></tr></table></figure><p>此时得到的结果是2。</p><p><strong>注意：</strong>如果是一条语句插入多条值，则返回的是插入第一条时自动生成的ID，而不是最后一条的。</p><p>比如我们再插入三条数据，不过换个写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO user(name) </span><br><span class="line">VALUES(&apos;王五&apos;),</span><br><span class="line">      (&apos;赵六&apos;),</span><br><span class="line">      (&apos;郑七&apos;);</span><br><span class="line"></span><br><span class="line">SELECT LAST_INSERT_ID();</span><br></pre></td></tr></table></figure><p>此时得到的结果是3，而<strong>不是</strong>5。</p><h3 id="获取自增序列"><a href="#获取自增序列" class="headerlink" title="获取自增序列"></a>获取自增序列</h3><p>在实际的项目中我们完全可以换个方式，避免上面👆的情况，作为一个程序员，何必没有困难，制造困难为难自己呢？接着看下一个更加通用的例子。</p><p>创建另一张表并初始化数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE sequence (</span><br><span class="line">    id INT AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">    seq_type VARCHAR(50) NOT NULL,</span><br><span class="line">    year INT NOT NULL,</span><br><span class="line">    current_val BIGINT NOT NULL</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO sequence(seq_type, year, current_val) VALUES(&apos;INVOICE&apos;, 2019, 0);</span><br></pre></td></tr></table></figure><p>每次在获取<code>current_val</code>之前，先通过<code>LAST_INSERT_ID(current_val + 1)</code>更新：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UPDATE sequence </span><br><span class="line">SET current_val = LAST_INSERT_ID(current_val + 1)</span><br><span class="line">WHERE seq_type = &apos;INVOICE&apos; AND year = 2019;</span><br><span class="line"></span><br><span class="line">SELECT LAST_INSERT_ID();</span><br></pre></td></tr></table></figure><p>这样每次都能获取自增之后的值了，但是也有例外的情况。比如两个人同时在获取新的值，A先做了update操作，然后B也做了update操作，然后A的操作由于某种原因回滚了，B的操作成功了，此时序列中间就会出现一个<code>洞</code>。虽然不是严格连续的，但是在大多数业务场景中，已经满足要求了。</p><p><strong>还需要注意的是</strong>，如果<code>seq_type</code>或者<code>year</code>条件不满足，那么这里的<code>SELECT LAST_INSERT_ID();</code>就会始终返回上一次的值，可能会导致意想不到的的错误。</p><h2 id="LAST-INSERT-ID-vs-MAX"><a href="#LAST-INSERT-ID-vs-MAX" class="headerlink" title="LAST_INSERT_ID() vs. MAX()"></a>LAST_INSERT_ID() vs. MAX()</h2><p><code>LAST_INSERT_ID()</code>是以数据库连接为基础的，即使有多个人同时通过多个连接获取Sequence也不会有问题，每个客户端会获取到属于他自己的序列号，不用担心会受到其他客户端的影响，或者影响其他客户端。在这种情况下，<code>MAX()</code>恐怕就不能正常工作了。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><blockquote><ul><li><a href="https://www.percona.com/community-blog/2018/10/12/generating-identifiers-auto_increment-sequence/" target="_blank" rel="noopener">https://www.percona.com/community-blog/2018/10/12/generating-identifiers-auto_increment-sequence/</a></li><li><a href="https://dev.mysql.com/doc/refman/8.0/en/information-functions.html#function_last-insert-id" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/information-functions.html#function_last-insert-id</a></li><li><a href="http://www.mysqltutorial.org/mysql-last_insert_id.aspx" target="_blank" rel="noopener">http://www.mysqltutorial.org/mysql-last_insert_id.aspx</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般如果遇到生成全局唯一的自增ID的需求时，往往第一反应都是直接利用数据的Sequence对象，简单，直接了当。但是MySQL偏偏不支持Sequence对象，那我们该如何是好呢？&lt;/p&gt;
&lt;h2 id=&quot;什么是Sequence&quot;&gt;&lt;a href=&quot;#什么是Sequence&quot; class=&quot;headerlink&quot; title=&quot;什么是Sequence&quot;&gt;&lt;/a&gt;什么是Sequence&lt;/h2&gt;&lt;p&gt;Sequence也叫做序列，一般用做表的主键，或者一些项目的编号等。一般具有以下几个特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全表唯一&lt;/li&gt;
&lt;li&gt;自增&lt;/li&gt;
&lt;li&gt;不一定严格连续（中间由于事务的回滚可能会出现&lt;code&gt;洞&lt;/code&gt;，比如1，2，3，5，6）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="database" scheme="https://codinglife.tech/categories/database/"/>
    
    
      <category term="mysql" scheme="https://codinglife.tech/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://codinglife.tech/2019/07/hello-world/"/>
    <id>https://codinglife.tech/2019/07/hello-world/</id>
    <published>2019-07-11T03:18:39.829Z</published>
    <updated>2019-07-15T15:06:17.694Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><a id="more"></a><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/writing.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Writing&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
